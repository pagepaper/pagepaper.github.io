---
title: 大端法、小端法、网络字节序
urlname: 61d8c7193f1b87013604e2667a0ec9df
categories : 
  - [编程开发]
date: 2009-01-18 01:01:01
updated: 2009-01-18 01:01:01
---
## 关于字节序(大端法、小端法)的定义
《UNXI网络编程》定义：术语“小端”和“大端”表示多字节值的哪一端(小端或大端)存储在该值的起始地址。小端存在起始地址，即是小端字节序(Little-Endian)；大端存在起始地址，即是大端字节序(Big-Endian)。
也可以说：
* 小端法就是低位字节排放在内存的低地址端即该值的起始地址，高位字节排放在内存的高地址端。
* 大端法就是高位字节排放在内存的低地址端即该值的起始地址，低位字节排放在内存的高地址端。

举个简单的例子，对于整形0x12345678。它在大端法和小端法的系统内存中，分别如图1所示的方式存放。

![](/images/61d8c7193f1b87013604e2667a0ec9df/1.jpg)


## 网络字节序
我们知道网络上的数据流是字节流，对于一个多字节数值，在进行网络传输的时候，先传递哪个字节？也就是说，当接收端收到第一个字节的时候，它是将这个字节作为高位还是低位来处理呢？
网络字节序定义：收到的第一个字节被当作高位看待，这就要求发送端发送的第一个字节应当是高位。而在发送端发送数据时，发送的第一个字节是该数字在内存中起始地址对应的字节。可见多字节数值在发送前，在内存中数值应该以大端法存放。
网络字节序说是大端字节序。
比如我们经过网络发送0x12345678这个整形，在80X86平台中，它是以小端法存放的，在发送前需要使用系统提供的htonl将其转换成大端法存放，如图2所示。

![](/images/61d8c7193f1b87013604e2667a0ec9df/2.jpg)

## 字节序测试程序
不同cpu平台上字节序通常也不一样，下面写个简单的C程序，它可以测试不同平台上的字节序。
``` c
#include <stdio.h>
#include <netinet/in.h>
void main()
{
    int i_num = 0x12345678;
    printf("[0]:0x%x\n", *((char *)&i_num + 0));
    printf("[1]:0x%x\n", *((char *)&i_num + 1));
    printf("[2]:0x%x\n", *((char *)&i_num + 2));
    printf("[3]:0x%x\n", *((char *)&i_num + 3));
 
    i_num = htonl(i_num);
    printf("[0]:0x%x\n", *((char *)&i_num + 0));
    printf("[1]:0x%x\n", *((char *)&i_num + 1));
    printf("[2]:0x%x\n", *((char *)&i_num + 2));
    printf("[3]:0x%x\n", *((char *)&i_num + 3));
}
```
在80X86CPU平台上，执行该程序得到如下结果：
> \[0\]:0x78
> \[1\]:0x56
> \[2\]:0x34
> \[3\]:0x12
> 
> \[0\]:0x12
> \[1\]:0x34
> \[2\]:0x56
> \[3\]:0x78

分析结果，在80X86平台上，系统将多字节中的低位存储在变量起始地址，使用小端法。htonl将i_num转换成网络字节序，可见网络字节序是大端法。

<font color="#FF0000"><strong>总结：80X86使用小端法，网络字节序使用大端法。</strong></font>
